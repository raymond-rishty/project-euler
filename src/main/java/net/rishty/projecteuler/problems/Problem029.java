package net.rishty.projecteuler.problems;

import com.google.common.base.Objects;
import com.google.common.base.Stopwatch;
import com.google.common.collect.ImmutableList;
import net.rishty.projecteuler.util.PrimeSieve;

import java.util.ArrayList;
import java.util.List;

/**
 Distinct powers
 Problem 29

 Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

 2^2=4, 2^3=8, 2^4=16, 2^5=32
 3^2=9, 3^3=27, 3^4=81, 3^5=243
 4^2=16, 4^3=64, 4^4=256, 4^5=1024
 5^2=25, 5^3=125, 5^4=625, 5^5=3125
 If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

 How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
 */
public class Problem029 {
    private class Power {
        int base;
        int exponent;

        Power(int base, int exponent) {
            this.base = base;
            this.exponent = exponent;
        }

        public PrimeFactoredInteger reduce(List<Integer> primes) {
            List<Power> primePowers = new ArrayList<>();
            int r = base;

            for (int prime : primes) {
                if (prime > this.base) {
                    break;
                }

                int count = 0;
                while (r % prime == 0) {
                    r /= prime;
                    count++;
                }

                if (count > 0) {
                    primePowers.add(new Power(prime, count * exponent));
                }

                if (r == 1) {
                    break;
                }
            }

            return new PrimeFactoredInteger(primePowers);
        }

        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof Power)) {
                return false;
            }

            Power that = (Power) obj;
            return this.base == that.base && this.exponent == that.exponent;
        }

        @Override
        public int hashCode() {
            return Objects.hashCode(this.base, this.exponent);
        }
    }

    private class PrimeFactoredInteger {
        private List<Power> powers;

        private PrimeFactoredInteger(List<Power> powers) {
            this.powers = powers;
        }

        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof PrimeFactoredInteger)) {
                return false;
            }

            PrimeFactoredInteger that = (PrimeFactoredInteger) obj;
            return Objects.equal(this.powers, that.powers);
        }

        @Override
        public int hashCode() {
            return Objects.hashCode(this.powers);
        }
    }

    public static void main(String[] args) {
        Stopwatch stopwatch = Stopwatch.createStarted();
        new Problem029().run();
        System.out.println(stopwatch.stop());
    }

    private void run() {
        int distinctTermCount = getDistinctTermCount(100);
        System.out.println(distinctTermCount);

    }

    public int getDistinctTermCount(int max) {
        List<Power> powers = new ArrayList<>();
        for (int a = 2; a <= max; a++) {
            for (int b = 2; b <= max; b++) {
                powers.add(new Power(a, b));
            }
        }

        ImmutableList<Integer> primes = PrimeSieve.getPrimes(max+1);

        return (int) powers
                .stream()
                .map(power -> power.reduce(primes))
                .distinct()
                .count();
    }
}
